<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
<title>AstroPro · Chart Builder</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;800&family=Crimson+Pro:ital,wght@0,300;0,400;1,300&display=swap');

:root {
  --bg:         #ffffff;
  --surface:    #ffffff;
  --border:     #c8d8f0;
  --border-mid: #90b8e0;
  --text:       #0d1e36;
  --text-dim:   #5a7a9a;
  --accent:     #1a5fa8;
  --sun:        #d4820a;
  --moon:       #1976d2;
  --mercury:    #6d3fc0;
  --venus:      #c2185b;
  --mars:       #c62828;
  --jupiter:    #1565c0;
  --saturn:     #00796b;
  --asc-col:    #1565c0;
  --mc-col:     #0288d1;
  --sector-a:   #eaf3fc;
  --sector-b:   #ddeef9;
  --grid:       #b8d4ef;
  --grid-maj:   #7aafd4;
  --z-glyph:    #5a8ab8;
  --h-num:      #90b8d8;
}

*,*::before,*::after{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
html{overscroll-behavior:none}

body{
  margin:0;
  background:var(--bg);
  color:var(--text);
  font-family:'Crimson Pro',Georgia,serif;
  display:flex;
  flex-direction:column;
  align-items:center;
  min-height:100vh;
  padding:16px 12px 48px;
  background-image: none;
  user-select:none;
  -webkit-user-select:none;
}

h1{
  font-family:'Cinzel',serif;
  font-size:14px;
  font-weight:600;
  letter-spacing:.30em;
  color:var(--text-dim);
  text-transform:uppercase;
  margin:0 0 14px;
}

.container{width:100%;max-width:480px;display:flex;flex-direction:column;gap:14px}

/* Chart wrapper */
.chart-wrap{
  width:100%;aspect-ratio:1;position:relative;
  touch-action:none;border-radius:50%;
  background:#f7fbff;
  box-shadow:0 0 0 1.5px var(--border),0 6px 28px rgba(20,80,160,.10),inset 0 0 48px rgba(140,190,240,.08);
  transition:box-shadow .18s;
}
.chart-wrap.over-planet{box-shadow:0 0 0 2.5px var(--accent),0 6px 32px rgba(21,101,192,.22),inset 0 0 48px rgba(140,190,240,.10)}
.chart-wrap.over-asc   {box-shadow:0 0 0 2.5px var(--asc-col),0 6px 32px rgba(21,101,192,.22),inset 0 0 48px rgba(140,190,240,.10)}

svg{width:100%;height:100%;display:block;overflow:visible}

/* SVG classes */
.sector-a{fill:var(--sector-a);stroke:var(--grid);stroke-width:.7}
.sector-b{fill:var(--sector-b);stroke:var(--grid);stroke-width:.7}
.tick    {stroke:var(--grid);    stroke-width:.7}
.tick-maj{stroke:var(--grid-maj);stroke-width:1.5}

.z-glyph{font-size:15px;fill:var(--z-glyph);font-family:'Cinzel',serif;cursor:default;transition:fill .15s}
.z-glyph:hover{fill:var(--accent)}

.h-num{font-size:9px;fill:var(--h-num);font-weight:800;font-family:'Cinzel',serif;pointer-events:none;text-anchor:middle;dominant-baseline:middle}
.deg-lbl{font-size:9px;fill:var(--text-dim);font-family:'Crimson Pro',serif;pointer-events:none;text-anchor:middle;dominant-baseline:middle}

.planet-glyph{font-size:22px;cursor:move;text-anchor:middle;dominant-baseline:middle;transition:font-size .12s}
.planet-glyph:hover {font-size:26px}
.planet-glyph.active{font-size:28px;filter:drop-shadow(0 0 5px currentColor);cursor:grabbing}

.asc-zone       {cursor:grab}
.asc-zone.active{cursor:grabbing}

.axis-asc{stroke:var(--asc-col);stroke-width:1.8;stroke-dasharray:4,3;opacity:.55;pointer-events:none}
.axis-mc {stroke:var(--mc-col); stroke-width:1.4;stroke-dasharray:3,4;opacity:.45;pointer-events:none}

.lbl-asc{font-size:9px;fill:var(--asc-col);font-family:'Cinzel',serif;font-weight:700;letter-spacing:.12em;pointer-events:none;text-anchor:middle;dominant-baseline:middle}
.lbl-dc {font-size:9px;fill:var(--asc-col);font-family:'Cinzel',serif;font-weight:600;letter-spacing:.10em;opacity:.65;pointer-events:none;text-anchor:middle;dominant-baseline:middle}
.lbl-mc {font-size:9px;fill:var(--mc-col); font-family:'Cinzel',serif;font-weight:700;letter-spacing:.12em;pointer-events:none;text-anchor:middle;dominant-baseline:middle}
.lbl-ic {font-size:9px;fill:var(--mc-col); font-family:'Cinzel',serif;font-weight:600;letter-spacing:.10em;opacity:.65;pointer-events:none;text-anchor:middle;dominant-baseline:middle}

/* Tooltip */
#tip{
  position:fixed;pointer-events:none;z-index:9999;
  background:#fff;border:1px solid var(--border-mid);color:var(--text);
  font-family:'Cinzel',serif;font-size:11px;letter-spacing:.07em;
  padding:5px 11px 4px;border-radius:8px;
  box-shadow:0 4px 16px rgba(20,80,160,.14);
  white-space:nowrap;opacity:0;transform:translateY(4px);
  transition:opacity .14s,transform .14s;left:-9999px;top:-9999px;
}
#tip.show{opacity:1;transform:translateY(0)}

/* ASC badge */
#asc-badge{
  position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
  background:rgba(255,255,255,.93);border:1px solid rgba(21,101,192,.28);
  border-radius:20px;padding:3px 12px;
  font-family:'Cinzel',serif;font-size:10px;letter-spacing:.08em;color:var(--asc-col);
  pointer-events:none;opacity:0;transition:opacity .18s;white-space:nowrap;z-index:5;
}
#asc-badge.show{opacity:1}

/* Axis panel */
.axis-panel{
  display:flex;align-items:center;justify-content:center;gap:18px;
  padding:10px 16px;background:#fff;border-radius:14px;
  border:1px solid var(--border);box-shadow:0 2px 8px rgba(20,80,160,.07);
}
.ax-item{display:flex;flex-direction:column;align-items:center;gap:1px}
.ax-lbl{font-family:'Cinzel',serif;font-size:8px;letter-spacing:.18em;color:var(--text-dim);text-transform:uppercase}
.ax-val{font-family:'Cinzel',serif;font-size:12px;font-weight:600;letter-spacing:.05em}
.ax-val.asc{color:var(--asc-col)}
.ax-val.dc {color:var(--asc-col);opacity:.6}
.ax-val.mc {color:var(--mc-col)}
.ax-val.ic {color:var(--mc-col);opacity:.6}
.ax-div{width:1px;height:28px;background:var(--border)}

/* Bank */
.bank-lbl{font-family:'Cinzel',serif;font-size:10px;letter-spacing:.20em;color:var(--text-dim);text-align:center;text-transform:uppercase}
.bank{
  display:grid;grid-template-columns:repeat(5,1fr);gap:10px;
  padding:14px;background:#fff;border-radius:16px;
  border:1px solid var(--border);box-shadow:0 2px 12px rgba(20,80,160,.08);
  touch-action:pan-y;
}
.p-btn{
  aspect-ratio:1;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:4px;
  font-size:28px;cursor:grab;background:#f0f7ff;
  border-radius:14px;border:1.5px solid var(--border);
  box-shadow:0 2px 6px rgba(20,80,160,.10);
  transition:transform .15s,opacity .2s,box-shadow .15s;
  touch-action:none;
  min-height:56px;
}
.p-btn span{font-family:'Cinzel',serif;font-size:9.5px;letter-spacing:.03em;color:var(--text-dim);text-transform:uppercase;font-weight:700}
.p-btn:hover   {transform:scale(1.09);box-shadow:0 4px 14px rgba(20,80,160,.20)}
.p-btn.dragging{opacity:.32;transform:scale(.93)}
.p-btn.placed  {opacity:.18;filter:grayscale(1);pointer-events:none}

/* Ghost */
#ghost{
  position:fixed;pointer-events:none;z-index:9998;
  font-size:40px;line-height:1;transform:translate(-50%,-50%);
  opacity:.88;filter:drop-shadow(0 3px 8px rgba(0,0,0,.20));display:none;
}

.hint{text-align:center;font-size:12px;color:var(--text-dim);font-style:italic;line-height:1.65;margin:0}
.hint strong{font-style:normal;color:var(--asc-col)}

.clear-btn{
  width:100%;padding:13px;border-radius:12px;
  border:1px solid var(--border);background:#f0f7ff;color:var(--accent);
  font-weight:700;font-size:12px;font-family:'Cinzel',serif;letter-spacing:.12em;
  cursor:pointer;transition:background .2s,box-shadow .2s;touch-action:manipulation;
}
.clear-btn:hover{background:#ddeef9;box-shadow:0 4px 14px rgba(21,101,192,.12)}

.c-sun    {fill:var(--sun);    color:var(--sun)}
.c-moon   {fill:var(--moon);   color:var(--moon)}
.c-mercury{fill:var(--mercury);color:var(--mercury)}
.c-venus  {fill:var(--venus);  color:var(--venus)}
.c-mars   {fill:var(--mars);   color:var(--mars)}
.c-jupiter{fill:var(--jupiter);color:var(--jupiter)}
.c-saturn {fill:var(--saturn); color:var(--saturn)}
.c-rahu   {fill:#4a235a;       color:#4a235a}
.c-ketu   {fill:#7b3f00;       color:#7b3f00}
</style>
</head>
<body>

<div id="ghost"></div>
<div id="tip"></div>

<div class="container">
  <h1>✦ Astro Chart Builder</h1>

  <div class="chart-wrap" id="chart-wrap">
    <svg id="svg" viewBox="0 0 400 400">
      <defs>
        <radialGradient id="cg" cx="50%" cy="50%" r="50%">
          <stop offset="0%"   stop-color="#f7fbff"/>
          <stop offset="100%" stop-color="#ddeef9"/>
        </radialGradient>
      </defs>
      <circle cx="200" cy="200" r="196" fill="url(#cg)" stroke="#b8d0ee" stroke-width="1"/>
      <circle cx="200" cy="200" r="115" fill="#eef6fd"  stroke="#b8d0ee" stroke-width="0.8"/>
      <g id="L-ticks"></g>
      <g id="L-sectors"></g>
      <g id="L-zodiac"></g>
      <g id="L-axes"></g>
      <g id="L-planets"></g>
      <g id="L-asc"></g>
    </svg>
    <div id="asc-badge"></div>
  </div>

  <p class="hint">
    Drag planets onto the ring · Hover for details · Slide to adjust degree · Double-tap removes<br>
    <strong>Drag the ASC ◆ marker</strong> to rotate the zodiac wheel
  </p>

  <div class="axis-panel">
    <div class="ax-item"><span class="ax-lbl">ASC</span><span class="ax-val asc" id="v-asc">Aries 0°</span></div>
    <div class="ax-div"></div>
    <div class="ax-item"><span class="ax-lbl">DC</span><span class="ax-val dc" id="v-dc">Libra 0°</span></div>
    <div class="ax-div"></div>
    <div class="ax-item"><span class="ax-lbl">MC</span><span class="ax-val mc" id="v-mc">Capricorn 0°</span></div>
    <div class="ax-div"></div>
    <div class="ax-item"><span class="ax-lbl">IC</span><span class="ax-val ic" id="v-ic">Cancer 0°</span></div>
  </div>

  <div class="bank-lbl">Planets</div>
  <div class="bank" id="bank">
    <button class="p-btn c-sun"     data-id="sun">☉<span>Sun</span></button>
    <button class="p-btn c-moon"    data-id="moon">☽<span>Moon</span></button>
    <button class="p-btn c-mercury" data-id="mercury">☿<span>Mercury</span></button>
    <button class="p-btn c-venus"   data-id="venus">♀<span>Venus</span></button>
    <button class="p-btn c-mars"    data-id="mars">♂<span>Mars</span></button>
    <button class="p-btn c-jupiter" data-id="jupiter">♃<span>Jupiter</span></button>
    <button class="p-btn c-saturn"  data-id="saturn">♄<span>Saturn</span></button>
    <button class="p-btn c-rahu"    data-id="rahu">☊<span>Rahu</span></button>
    <button class="p-btn c-ketu"    data-id="ketu">☋<span>Ketu</span></button>
  </div>

  <button class="clear-btn" id="clear-btn">✕ Clear Chart</button>
</div>

<script>
(function(){
'use strict';

/* ── Constants ──────────────────────────────────────────────────────────── */
const NS      = 'http://www.w3.org/2000/svg';
const CX = 200, CY = 200;
const R_OUT   = 185;   // outer ring
const R_IN    = 115;   // inner ring
const R_MID   = 148;   // planet base radius
const VB      = 400;   // viewBox size

/* ── Pure math ──────────────────────────────────────────────────────────────
   SINGLE source of truth for all coordinate conversions.

   zodiacDeg : ecliptic longitude  0=Aries … 360, increases CCW on celestial sphere
   screenRad : SVG angle, 0=right, π/2=down (CW on screen)

   ASC is fixed at screen angle π (the left side of the chart).

   Forward  (zodiac → screen):
     screenRad = π − (zodiacDeg − ascDeg) × π/180

   Inverse  (screen → zodiac):
     zodiacDeg = ascDeg + 180 − screenDeg     (degrees)
─────────────────────────────────────────────────────────────────────────── */
function mod360(x) { return ((x % 360) + 360) % 360; }
function toRad(d)  { return d * Math.PI / 180; }
function toDeg(r)  { return r * 180 / Math.PI; }

// zodiac degree → SVG screen radians
function z2s(z, asc) { return toRad(180 - mod360(z - asc)); }

// SVG screen angle (degrees, raw atan2) → zodiac degree
function s2z(sDeg, asc) { return mod360(asc + 180 - sDeg); }

// polar coords relative to chart centre
function pol(r, rad) { return { x: CX + r * Math.cos(rad), y: CY + r * Math.sin(rad) }; }

// Signed angular delta A→B, shortest path, range (-180, 180]
function angDelta(a, b) {
  let d = b - a;
  if (d >  180) d -= 360;
  if (d < -180) d += 360;
  return d;
}

/* ── State ─────────────────────────────────────────────────────────────── */
let ascDeg  = 0;                   // zodiac degree at the ASC position
const PLN   = new Map();           // id → { z: zodiacDeg }
let stackCache = new Map();        // id → stackIndex, frozen during scrub

/* ── Gesture state machine ──────────────────────────────────────────────────
   mode: null | 'bank-drag' | 'planet-scrub' | 'asc-drag'
─────────────────────────────────────────────────────────────────────────── */
const GS = {
  mode: null, id: null, trackId: null,
  startSDeg: 0,   // screen angle (degrees) at gesture start
  startZ:    0,   // zodiac deg at start (planet.z or ascDeg)
  startX: 0, startY: 0,
  pxMoved: 0,
};
function resetGS() {
  GS.mode = GS.id = GS.trackId = null;
  GS.startSDeg = GS.startZ = GS.startX = GS.startY = GS.pxMoved = 0;
}

/* ── DOM refs ───────────────────────────────────────────────────────────── */
const wrap  = document.getElementById('chart-wrap');
const ghost = document.getElementById('ghost');
const tipEl = document.getElementById('tip');
const badge = document.getElementById('asc-badge');
const L = {
  ticks:   document.getElementById('L-ticks'),
  sectors: document.getElementById('L-sectors'),
  zodiac:  document.getElementById('L-zodiac'),
  axes:    document.getElementById('L-axes'),
  planets: document.getElementById('L-planets'),
  asc:     document.getElementById('L-asc'),
};

/* ── SVG helpers ────────────────────────────────────────────────────────── */
function svgEl(tag, attrs) {
  const e = document.createElementNS(NS, tag);
  for (const [k,v] of Object.entries(attrs)) e.setAttribute(k, v);
  return e;
}
function svgTxt(str, r, rad, cls, parent) {
  const p = pol(r, rad);
  const t = svgEl('text', { x: p.x, y: p.y, class: cls });
  t.textContent = str;
  parent.appendChild(t);
  return t;
}

/* ── Zodiac / planet data ───────────────────────────────────────────────── */
const Z_SYM  = ['♈','♉','♊','♋','♌','♍','♎','♏','♐','♑','♒','♓'];
const Z_NAME = ['Aries','Taurus','Gemini','Cancer','Leo','Virgo',
                'Libra','Scorpio','Sagittarius','Capricorn','Aquarius','Pisces'];
const P_SYM  = { sun:'☉', moon:'☽', mercury:'☿', venus:'♀', mars:'♂', jupiter:'♃', saturn:'♄', rahu:'☊', ketu:'☋' };
const P_NAME = { sun:'Sun', moon:'Moon', mercury:'Mercury', venus:'Venus',
                 mars:'Mars', jupiter:'Jupiter', saturn:'Saturn', rahu:'Rahu', ketu:'Ketu' };

function zSign(z) { return Math.floor(mod360(z) / 30); }
function zDeg(z)  { return mod360(z) % 30; }
function fmtZ(z)  { return `${Z_NAME[zSign(z)]} ${Math.floor(zDeg(z))}°`; }

/* ── Client → chart helpers ─────────────────────────────────────────────── */
function clientSDeg(cx, cy) {
  const r  = wrap.getBoundingClientRect();
  const sx = VB / r.width, sy = VB / r.height;
  return toDeg(Math.atan2((cy - r.top) * sy - CY, (cx - r.left) * sx - CX));
}

function clientVBDist(cx, cy) {
  const r  = wrap.getBoundingClientRect();
  const sx = VB / r.width, sy = VB / r.height;
  const vx = (cx - r.left) * sx - CX;
  const vy = (cy - r.top)  * sy - CY;
  return Math.sqrt(vx * vx + vy * vy);
}

function inRing(cx, cy)   { const d = clientVBDist(cx,cy); return d >= R_IN  && d <= R_OUT; }
function inCircle(cx, cy) { return clientVBDist(cx, cy) <= R_OUT + 14; }

// ASC handle lives at screen angle 180° on the outer ring
function nearAsc(cx, cy) {
  const d = clientVBDist(cx, cy);
  if (d < R_OUT - 22 || d > R_OUT + 30) return false;
  const sd   = clientSDeg(cx, cy);
  let diff   = Math.abs(sd - 180);
  if (diff > 180) diff = 360 - diff;
  return diff < 22;
}

/* ── Tooltip ────────────────────────────────────────────────────────────── */
let tipTimer = null;
function showTip(text, cx, cy)   { clearTimeout(tipTimer); tipEl.textContent = text; tipEl.classList.add('show'); _posTip(cx, cy); }
function updateTip(text, cx, cy) { tipEl.textContent = text; _posTip(cx, cy); tipEl.classList.add('show'); }
function _posTip(cx, cy) {
  tipEl.style.left = '-9999px'; tipEl.style.top = '-9999px';
  const tw = tipEl.offsetWidth, th = tipEl.offsetHeight;
  let tx = cx + 14, ty = cy - th - 10;
  if (tx + tw > window.innerWidth  - 8) tx = cx - tw - 14;
  if (ty < 8) ty = cy + 16;
  tipEl.style.left = tx + 'px'; tipEl.style.top = ty + 'px';
}
function hideTip(ms) { clearTimeout(tipTimer); tipTimer = setTimeout(() => tipEl.classList.remove('show'), ms ?? 0); }

/* ── ASC badge ──────────────────────────────────────────────────────────── */
let badgeTimer = null;
function showBadge() {
  clearTimeout(badgeTimer);
  badge.textContent = `ASC  ${fmtZ(ascDeg)}`;
  badge.classList.add('show');
}
function hideBadge(ms) {
  clearTimeout(badgeTimer);
  badgeTimer = setTimeout(() => badge.classList.remove('show'), ms ?? 0);
}

/* ── Axis panel ─────────────────────────────────────────────────────────── */
function updatePanel() {
  document.getElementById('v-asc').textContent = fmtZ(ascDeg);
  document.getElementById('v-dc') .textContent = fmtZ(ascDeg + 180);
  document.getElementById('v-mc') .textContent = fmtZ(ascDeg + 90);
  document.getElementById('v-ic') .textContent = fmtZ(ascDeg + 270);
}

/* ── Stacking ───────────────────────────────────────────────────────────── */
function buildStack() {
  const list = [];
  PLN.forEach((d,id) => list.push({ id, z: d.z }));
  list.sort((a,b) => a.z - b.z);

  const THRESH = 5;
  const clusters = [];
  let cur = [];
  for (const e of list) {
    if (!cur.length) { cur.push(e); continue; }
    let diff = Math.abs(e.z - cur[cur.length-1].z);
    if (diff > 180) diff = 360 - diff;
    diff <= THRESH ? cur.push(e) : (clusters.push(cur), cur = [e]);
  }
  if (cur.length) clusters.push(cur);

  // wrap-around merge
  if (clusters.length >= 2) {
    const f = clusters[0], lc = clusters[clusters.length-1];
    let diff = Math.abs(f[0].z + 360 - lc[lc.length-1].z);
    if (diff > 180) diff = 360 - diff;
    if (diff <= THRESH) { clusters[0] = [...lc,...f]; clusters.pop(); }
  }

  const res = new Map();
  clusters.forEach(cl => cl.forEach((e,i) => res.set(e.id, i)));
  return res;
}

/* ── planet tip text ────────────────────────────────────────────────────── */
function pTipText(id) { return `${P_NAME[id]}  ·  ${fmtZ(PLN.get(id).z)}`; }

/* ── Full render ────────────────────────────────────────────────────────── */
function render() {
  stackCache = buildStack();
  _drawTicks();
  _drawSectors();
  _drawZodiac();
  _drawAxes();
  _drawPlanets();
  _drawAscHandle();
  updatePanel();
  _syncBank();
}

function _drawTicks() {
  const g = L.ticks; g.innerHTML = '';
  for (let d = 0; d < 360; d++) {
    const rad = z2s(d, ascDeg);
    const maj = d % 30 === 0, mid = d % 5 === 0;
    const len = maj ? 12 : mid ? 7 : 4;
    const p1  = pol(R_OUT, rad), p2 = pol(R_OUT - len, rad);
    g.appendChild(svgEl('line',{ x1:p1.x,y1:p1.y,x2:p2.x,y2:p2.y, class:maj?'tick-maj':'tick' }));
  }
}

function _drawSectors() {
  const g = L.sectors; g.innerHTML = '';
  for (let i = 0; i < 12; i++) {
    // House i spans from ascDeg + i*30 to ascDeg + (i+1)*30
    const r1  = z2s(ascDeg + i * 30,       ascDeg);
    const r2  = z2s(ascDeg + (i + 1) * 30, ascDeg);
    const rm  = z2s(ascDeg + i * 30 + 15,  ascDeg);
    const o1  = pol(R_OUT, r1), o2 = pol(R_OUT, r2);
    const i1  = pol(R_IN,  r2), i2 = pol(R_IN,  r1);
    g.appendChild(svgEl('path',{
      d: `M${o1.x},${o1.y} A${R_OUT},${R_OUT} 0 0 0 ${o2.x},${o2.y}`
       + `L${i1.x},${i1.y} A${R_IN},${R_IN}   0 0 1 ${i2.x},${i2.y}Z`,
      class: i%2===0?'sector-a':'sector-b',
    }));
    const s1 = pol(R_IN, r1), s2 = pol(R_OUT, r1);
    g.appendChild(svgEl('line',{ x1:s1.x,y1:s1.y,x2:s2.x,y2:s2.y,class:'tick-maj' }));
    svgTxt(i+1, R_IN+18, rm, 'h-num', g);
  }
}

function _drawZodiac() {
  const g = L.zodiac; g.innerHTML = '';
  for (let i = 0; i < 12; i++) {
    const rad = z2s(i * 30 + 15, ascDeg);
    const p   = pol(R_OUT + 22, rad);
    const t   = svgEl('text',{ x:p.x,y:p.y,class:'z-glyph','text-anchor':'middle','dominant-baseline':'middle' });
    t.textContent = Z_SYM[i];
    t.addEventListener('mouseenter', e => showTip(Z_NAME[i], e.clientX, e.clientY));
    t.addEventListener('mousemove',  e => _posTip(e.clientX, e.clientY));
    t.addEventListener('mouseleave', () => hideTip(80));
    g.appendChild(t);
  }
}

function _drawAxes() {
  const g = L.axes; g.innerHTML = '';
  function axis(z1, z2, cls, l1, lc1, l2, lc2) {
    const r1 = z2s(z1, ascDeg), r2 = z2s(z2, ascDeg);
    const pa = pol(R_OUT+2,r1), pb = pol(R_OUT+2,r2);
    g.appendChild(svgEl('line',{ x1:pa.x,y1:pa.y,x2:pb.x,y2:pb.y,class:cls }));
    const LR = R_OUT + 36;
    svgTxt(l1, LR, r1, lc1, g);
    svgTxt(l2, LR, r2, lc2, g);
  }
  axis(ascDeg,      ascDeg+180,'axis-asc','ASC','lbl-asc','DC','lbl-dc');
  axis(ascDeg+90,   ascDeg+270,'axis-mc', 'MC', 'lbl-mc', 'IC','lbl-ic');
}

function _drawPlanets() {
  const g = L.planets; g.innerHTML = '';
  PLN.forEach((data, id) => {
    const si   = stackCache.get(id) || 0;
    const r    = R_MID + si * 22;
    const rl   = Math.min(r + 18, R_OUT - 9);
    const rad  = z2s(data.z, ascDeg);
    const pos  = pol(r, rad), lpos = pol(rl, rad);
    const isScrub = GS.mode === 'planet-scrub' && GS.id === id;

    const grp = document.createElementNS(NS,'g');
    grp.setAttribute('data-pid', id);

    const dl = svgEl('text',{ x:lpos.x,y:lpos.y,class:'deg-lbl' });
    dl.textContent = `${Math.floor(zDeg(data.z))}°`;
    grp.appendChild(dl);

    const pg = svgEl('text',{ x:pos.x,y:pos.y,class:`planet-glyph c-${id}${isScrub?' active':''}` });
    pg.textContent = P_SYM[id];
    pg.addEventListener('mouseenter', e => showTip(pTipText(id),   e.clientX, e.clientY));
    pg.addEventListener('mousemove',  e => _posTip(e.clientX,      e.clientY));
    pg.addEventListener('mouseleave', () => hideTip(80));
    pg.addEventListener('dblclick',   () => { hideTip(); PLN.delete(id); render(); });
    pg.addEventListener('mousedown',  e => { e.preventDefault(); _beginMouseScrub(id, e.clientX, e.clientY); });
    grp.appendChild(pg);
    g.appendChild(grp);
  });
}

function _drawAscHandle() {
  const g = L.asc; g.innerHTML = '';
  // ASC is always at screen angle π regardless of ascDeg — that's the definition
  const rad  = Math.PI;
  const hp   = pol(R_OUT + 5, rad);
  const drag = GS.mode === 'asc-drag';

  const zone = document.createElementNS(NS,'g');
  zone.setAttribute('class', drag ? 'asc-zone active' : 'asc-zone');

  zone.appendChild(svgEl('circle',{ cx:hp.x,cy:hp.y,r:18,fill:'transparent' }));
  zone.appendChild(svgEl('circle',{
    cx:hp.x,cy:hp.y,
    r: drag ? 14 : 10,
    fill:`rgba(21,101,192,${drag?'.22':'.12'})`,
    stroke:'var(--asc-col)',
    'stroke-width': drag ? 2 : 1.5,
  }));
  const s = 6;
  zone.appendChild(svgEl('polygon',{
    points:`${hp.x},${hp.y-s} ${hp.x+s*.6},${hp.y} ${hp.x},${hp.y+s} ${hp.x-s*.6},${hp.y}`,
    fill:'var(--asc-col)',
    opacity: drag ? '1' : '.88',
  }));

  zone.addEventListener('mousedown', e => { e.preventDefault(); _beginMouseAscDrag(e.clientX, e.clientY); });
  g.appendChild(zone);
}

function _syncBank() {
  document.querySelectorAll('.p-btn').forEach(btn => {
    const id = btn.dataset.id;
    btn.classList.toggle('placed',   PLN.has(id));
    btn.classList.toggle('dragging', GS.mode === 'bank-drag' && GS.id === id);
  });
}

/* ── Partial planet update (during scrub, no layer wipe) ───────────────── */
function _partialMovePlanet(id) {
  const grp = L.planets.querySelector(`[data-pid="${id}"]`);
  if (!grp) { render(); return; }
  const data = PLN.get(id);
  const si   = stackCache.get(id) || 0;  // frozen stack during scrub
  const r    = R_MID + si * 22;
  const rl   = Math.min(r + 18, R_OUT - 9);
  const rad  = z2s(data.z, ascDeg);
  const pos  = pol(r, rad), lpos = pol(rl, rad);
  const pg   = grp.querySelector('.planet-glyph');
  const dl   = grp.querySelector('.deg-lbl');
  if (pg) { pg.setAttribute('x', pos.x);  pg.setAttribute('y', pos.y); }
  if (dl) { dl.setAttribute('x', lpos.x); dl.setAttribute('y', lpos.y); dl.textContent = `${Math.floor(zDeg(data.z))}°`; }
}

/* ── Mouse: planet scrub ────────────────────────────────────────────────── */
function _beginMouseScrub(id, cx, cy) {
  GS.mode = 'planet-scrub'; GS.id = id;
  GS.startSDeg = clientSDeg(cx, cy);
  GS.startZ    = PLN.get(id).z;
  document.body.style.cursor = 'grabbing';
  showTip(pTipText(id), cx, cy);
  // immediate active class
  const pg = L.planets.querySelector(`[data-pid="${id}"] .planet-glyph`);
  if (pg) pg.classList.add('active');

  function onMove(e) {
    e.preventDefault();
    const d = angDelta(GS.startSDeg, clientSDeg(e.clientX, e.clientY));
    // zodiac opposite to screen rotation: subtract delta
    PLN.get(id).z = mod360(GS.startZ - d);
    updateTip(pTipText(id), e.clientX, e.clientY);
    _partialMovePlanet(id);
  }
  function onUp() {
    window.removeEventListener('mousemove', onMove);
    window.removeEventListener('mouseup',   onUp);
    document.body.style.cursor = '';
    hideTip(1200);
    resetGS();
    render();
  }
  window.addEventListener('mousemove', onMove, { passive:false });
  window.addEventListener('mouseup',   onUp);
}

/* ── Mouse: ASC drag ────────────────────────────────────────────────────── */
function _beginMouseAscDrag(cx, cy) {
  GS.mode = 'asc-drag';
  GS.startSDeg = clientSDeg(cx, cy);
  GS.startZ    = ascDeg;
  document.body.style.cursor = 'grabbing';
  wrap.classList.add('over-asc');
  showBadge();
  _drawAscHandle();

  function onMove(e) {
    e.preventDefault();
    const d = angDelta(GS.startSDeg, clientSDeg(e.clientX, e.clientY));
    // dragging clockwise on screen → ascDeg increases (more zodiac forward)
    ascDeg = mod360(GS.startZ - d);
    showBadge();
    _drawTicks(); _drawSectors(); _drawZodiac(); _drawAxes(); _drawPlanets(); _drawAscHandle(); updatePanel();
  }
  function onUp() {
    window.removeEventListener('mousemove', onMove);
    window.removeEventListener('mouseup',   onUp);
    document.body.style.cursor = '';
    wrap.classList.remove('over-asc');
    hideBadge(2000);
    resetGS();
    render();
  }
  window.addEventListener('mousemove', onMove, { passive:false });
  window.addEventListener('mouseup',   onUp);
}

/* ── Desktop drag-and-drop ──────────────────────────────────────────────── */
document.querySelectorAll('.p-btn').forEach(btn => {
  btn.setAttribute('draggable','true');
  btn.addEventListener('dragstart', e => {
    e.dataTransfer.setData('text/plain', btn.dataset.id);
    e.dataTransfer.effectAllowed = 'copy';
  });
});
wrap.addEventListener('dragover',  e => { e.preventDefault(); wrap.classList.toggle('over-planet', inCircle(e.clientX,e.clientY)); });
wrap.addEventListener('dragleave', () => wrap.classList.remove('over-planet'));
wrap.addEventListener('drop', e => {
  e.preventDefault();
  wrap.classList.remove('over-planet');
  const id = e.dataTransfer.getData('text/plain');
  if (id && inRing(e.clientX, e.clientY)) { _place(id, e.clientX, e.clientY); render(); }
});

function _place(id, cx, cy) {
  const z = s2z(clientSDeg(cx, cy), ascDeg);
  // de-duplicate
  let resolved = z;
  PLN.forEach((d, pid) => { if (pid !== id && Math.abs(d.z - resolved) < 0.12) resolved += 0.25; });
  PLN.set(id, { z: mod360(resolved) });
}

/* ── Touch: unified handler ─────────────────────────────────────────────── */
const dblTapTS = new Map();   // id → timestamp for double-tap detection

function _touchById(list, id) {
  for (let i = 0; i < list.length; i++) if (list[i].identifier === id) return list[i];
  return null;
}

document.addEventListener('touchstart',  _onTS, { passive:false });
document.addEventListener('touchmove',   _onTM, { passive:false });
document.addEventListener('touchend',    _onTE, { passive:false });
document.addEventListener('touchcancel', _onTE, { passive:false });

function _onTS(e) {
  if (GS.mode !== null) return;          // guard: only one gesture at a time
  const t = e.changedTouches[0];
  if (!t) return;
  const cx = t.clientX, cy = t.clientY;

  /* 1. ASC handle */
  if (nearAsc(cx, cy)) {
    e.preventDefault();
    GS.mode = 'asc-drag'; GS.trackId = t.identifier;
    GS.startSDeg = clientSDeg(cx, cy); GS.startZ = ascDeg;
    GS.startX = cx; GS.startY = cy; GS.pxMoved = 0;
    wrap.classList.add('over-asc');
    showBadge(); _drawAscHandle();
    return;
  }

  /* 2. Bank button */
  const btn = t.target.closest('.p-btn');
  if (btn && !btn.classList.contains('placed')) {
    e.preventDefault();
    GS.mode = 'bank-drag'; GS.id = btn.dataset.id; GS.trackId = t.identifier;
    GS.startX = cx; GS.startY = cy; GS.pxMoved = 0;
    ghost.textContent = P_SYM[GS.id];
    ghost.style.left = cx+'px'; ghost.style.top = cy+'px'; ghost.style.display = 'block';
    _syncBank();
    return;
  }

  /* 3. Placed planet glyph */
  let el = t.target;
  while (el && el !== document.body) {
    if (el.classList && el.classList.contains('planet-glyph')) break;
    el = el.parentElement;
  }
  if (el && el.classList && el.classList.contains('planet-glyph')) {
    let pid = null;
    for (const cls of el.classList) { if (cls.startsWith('c-') && cls.length > 2) { pid = cls.slice(2); break; } }
    if (pid && PLN.has(pid)) {
      e.preventDefault();
      GS.mode = 'planet-scrub'; GS.id = pid; GS.trackId = t.identifier;
      GS.startSDeg = clientSDeg(cx, cy); GS.startZ = PLN.get(pid).z;
      GS.startX = cx; GS.startY = cy; GS.pxMoved = 0;
      el.classList.add('active');
      showTip(pTipText(pid), cx, cy);
    }
  }
}

function _onTM(e) {
  if (GS.mode === null) return;
  const t = _touchById(e.changedTouches, GS.trackId) || _touchById(e.touches, GS.trackId);
  if (!t) return;
  e.preventDefault();

  const cx = t.clientX, cy = t.clientY;
  GS.pxMoved = Math.sqrt((cx-GS.startX)**2 + (cy-GS.startY)**2);

  if (GS.mode === 'bank-drag') {
    ghost.style.left = cx+'px'; ghost.style.top = cy+'px';
    wrap.classList.toggle('over-planet', inCircle(cx, cy));

  } else if (GS.mode === 'planet-scrub') {
    const d = angDelta(GS.startSDeg, clientSDeg(cx, cy));
    PLN.get(GS.id).z = mod360(GS.startZ - d);
    updateTip(pTipText(GS.id), cx, cy);
    _partialMovePlanet(GS.id);

  } else if (GS.mode === 'asc-drag') {
    const d = angDelta(GS.startSDeg, clientSDeg(cx, cy));
    ascDeg = mod360(GS.startZ - d);
    showBadge();
    _drawTicks(); _drawSectors(); _drawZodiac(); _drawAxes(); _drawPlanets(); _drawAscHandle(); updatePanel();
  }
}

function _onTE(e) {
  if (GS.mode === null) return;
  const t = _touchById(e.changedTouches, GS.trackId);
  if (!t) return;
  e.preventDefault();

  const cx = t.clientX, cy = t.clientY;
  const mode = GS.mode, id = GS.id, px = GS.pxMoved;

  if (mode === 'bank-drag') {
    ghost.style.display = 'none';
    wrap.classList.remove('over-planet');
    if (inRing(cx, cy)) { _place(id, cx, cy); }

  } else if (mode === 'planet-scrub') {
    hideTip(1200);
    if (px < 6) {   // treat as tap for double-tap detection
      const now  = Date.now();
      const last = dblTapTS.get(id) || 0;
      if (now - last < 350) { PLN.delete(id); hideTip(0); }
      dblTapTS.set(id, now);
    }

  } else if (mode === 'asc-drag') {
    wrap.classList.remove('over-asc');
    hideBadge(2000);
  }

  resetGS();
  render();
}

/* ── Misc ───────────────────────────────────────────────────────────────── */
document.addEventListener('selectstart', e => { if (GS.mode !== null) e.preventDefault(); });

let rTimer;
window.addEventListener('resize', () => { clearTimeout(rTimer); rTimer = setTimeout(render, 120); });

document.getElementById('clear-btn').addEventListener('click', () => { PLN.clear(); render(); });

/* ── Boot ───────────────────────────────────────────────────────────────── */
render();

})();
</script>
</body>
</html>
